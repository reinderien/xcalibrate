#!/usr/bin/env python3
import datetime
import locale
import re
import subprocess
import numpy as np


PROP_NAMES = (
    'libinput Calibration Matrix',       # libinput driver only
    'Coordinate Transformation Matrix',  # fallback, probably evdev driver
)


def xinput(*args: str) -> str:
    return subprocess.check_output(
        args=('/usr/bin/xinput', *args), text=True,
    )


def get_devs(pointer_only: bool = True) -> dict[int, str]:
    pattern = r'''(?xim)
        ^.*?           # line start, any (lazy) prefix
        (?P<name>      # greedy name, beginning with a letter,
            [a-z].*\S  # ending with any non-space character
        )
        \s*id=         # ID marker
        (?P<id>        # numeric ID
            \d+
        )
        \s*
        \[?slave\s*%s  # must be a pointer device for pointer_only mode
    ''' % ('pointer' if pointer_only else '.+?')
    stdout = xinput('--list', '--short')
    matches = re.finditer(pattern, stdout)
    return {int(match['id']): match['name'] for match in matches}


def print_devs(devs: dict[int, str]) -> None:
    print(f'{"ID":4s} {"Name":35s}')
    for i, name in sorted(devs.items()):
        print(f'{i:4d} {name:35s}')
    print()


def choose_preferred(devs: dict[int, str]) -> int:
    preferred = next(
        (i for (i, n) in devs.items() if 'touch' in n.lower()),
        None,
    )
    if preferred is None:
        return next(iter(devs.keys()))
    return preferred


def choose_dev(devs: dict[int, str], preferred: int) -> int:
    while True:
        devstr = input(f'Device to calibrate [{preferred}]: ')
        if devstr == '':
            return preferred
        try:
            dev = int(devstr)
        except ValueError:
            continue
        if dev in devs.keys():
            return dev


def read_prop(dev_id: int, names: tuple[str, ...]) -> tuple[str | None, str | None]:
    names = '|'.join(re.escape(name) for name in names)
    pattern = r'''(?xim)
        ^\s*      # line start, greedy spaces
        (?P<name>
            %s    # interpolated
        )
        \s*       # greedy spaces
        \(\d+\):  # numeric ID, not captured
        \s*       # greedy spaces
        (?P<value>
            .+?   # lazy value content
        )
        $         # line end
    ''' % names
    stdout = xinput('--list-props', str(dev_id))
    match = re.search(pattern, stdout)
    if match is None:
        return None, None
    return match['name'], match['value']


def read_cal(dev_id: int) -> tuple[
    str,         # xinput property name
    np.ndarray,  # calibration
    np.ndarray,  # inverse calibration
]:
    name, value = read_prop(dev_id, PROP_NAMES)
    if name is None:
        print(f'$ xinput --list-props {dev_id}')
        print('does not contain any of these properties:')
        for name in PROP_NAMES:
            print('   ', name)
        print("So I don't know how to calibrate it.")
        exit(1)

    cal = np.fromstring(value, sep=',').reshape((3, 3))
    print(f'Old calibration ({name}):')
    print(cal)
    print()
    return name, cal, np.linalg.inv(cal)


def ask(q: str) -> bool:
    do = input(q + ' [y]: ')
    return (do or 'y')[:1].lower() == 'y'


def choose_points(p_min: int = 3, default: int = 4) -> int:
    while True:
        p_str = input(f'Point count (min {p_min}) [{default}]: ')
        if p_str == '':
            return default
        try:
            p = int(p_str)
        except ValueError:
            continue

        if p >= p_min:
            return p


def transform(x: float, y: float, cal: np.ndarray) -> np.ndarray:
    return cal[:2, :] @ (x, y, 1)


def show_tk(
    n_points: int, old_cal_inv: np.ndarray, new_cal: np.ndarray | None = None,
) -> tuple[
    np.ndarray,  # normalised mouse points
    np.ndarray,  # normalised screen points
]:
    import tkinter

    root = tkinter.Tk()
    X, Y = None, None
    root.attributes('-fullscreen', True)
    # as the above line doesn't work on all screens
    # we also force the geometry to be the full size
    w, h = root.winfo_screenwidth(), root.winfo_screenheight()
    root.geometry(f'{w}x{h}')
    canvas = tkinter.Canvas(root)

    def resize(event: tkinter.Event) -> None:
        nonlocal X, Y
        X, Y = event.width, event.height
        draw_legends()
        next_point()
    canvas.bind('<Configure>', resize)
    canvas.pack(expand=True, fill='both')
    legend_y = None

    def legend(text: str, colour: str = '#000') -> None:
        nonlocal legend_y
        canvas.create_text(X/2, legend_y, text=text, fill=colour)
        legend_y += 12

    def draw_legends() -> None:
        nonlocal legend_y
        legend_y = Y * 0.3
        legend('Esc to cancel.')
        legend('Raw point in black')
        legend('Old cal point in blue', '#00F')
        legend('Target point in red', '#F00')
        if new_cal is not None:
            legend('New cal point in green', '#0F0')

    index = -1
    n_cols = int(np.ceil(np.sqrt(n_points)))
    n_rows = int(np.ceil(n_points / n_cols))
    screen_points = 0.1 + 0.8*np.stack(
        np.divmod(  # returns y, x tuple
            np.arange(n_points, dtype=np.float64),
            n_cols,
        ), axis=1,  # returns (n, 2=yx) array
    )[:, ::-1]/(    # flip to (n, 2=xy) array
        n_cols - 1, n_rows - 1,  # normalise
    )
    mouse_points = np.empty_like(screen_points)
    sensitive = False

    def next_point() -> None:
        nonlocal index, sensitive
        index += 1
        sensitive = index < n_points
        if sensitive:
            draw_target(*screen_points[index])
        else:
            root.after(1000, root.destroy)

    def cross(px: float, py: float, colour: str) -> None:
        x, y = px*X, py*Y
        canvas.create_line(x-10, y, x+10, y, fill=colour)
        canvas.create_line(x, y-10, x, y+10, fill=colour)

    def draw_target(px: float, py: float) -> None:
        x, y = px*X, py*Y
        canvas.create_oval(x-10, y-10, x+10, y+10, outline='#F00', width=3)
        cross(px, py, '#F00')

    def cancel_cal(_) -> None:
        print('Calibration cancelled')
        nonlocal screen_points, mouse_points
        screen_points, mouse_points = np.empty((2, 0, 2))
        root.destroy()

    root.bind('<Escape>', cancel_cal)
    canvas.bind('<Escape>', cancel_cal)

    def indicator(sx: float, sy: float, px: float, py: float, colour: str) -> None:
        canvas.create_line(X*sx, Y*sy, X*px, Y*py, fill=colour)
        cross(px, py, colour)

    def click(event: tkinter.Event) -> None:
        nonlocal sensitive
        if not sensitive:
            return
        sensitive = False
        sx, sy = screen_points[index]
        ox, oy = event.x/X, event.y/Y            # old-calibrated
        ux, uy = transform(ox, oy, old_cal_inv)  # uncalibrated
        mouse_points[index] = ux, uy
        indicator(sx, sy, ox, oy, '#00F')
        indicator(sx, sy, ux, uy, '#000')

        if new_cal is not None:
            nx, ny = transform(ux, uy, new_cal)  # new-calibrated (test only)
            indicator(sx, sy, nx, ny, '#0F0')

        canvas.after(500, next_point)  # click debounce delay

    canvas.bind('<Button-1>', click)
    root.mainloop()
    return mouse_points, screen_points


def fit(
    mouse_points: np.ndarray, screen_points: np.ndarray, expected_rank: int = 3,
) -> tuple[
    np.ndarray,  # transform matrix
    float,       # quality metric
]:
    homo_mouse = np.hstack((  # to homogeneous matrix
        mouse_points,
        np.ones_like(mouse_points, shape=(len(mouse_points), 1)),
    ))
    transform, residuals, rank, singular = np.linalg.lstsq(homo_mouse, screen_points, rcond=None)
    if rank != expected_rank:
        print(f'Warning: deficient transformation of rank {rank}. Please try calibrating again.')
    quality = -np.log10(residuals.mean())
    return transform, quality


def calibrate(
    mouse_points: np.ndarray, screen_points: np.ndarray, disable_rot: bool,
) -> tuple[
    np.ndarray,  # new cal matrix
    float,       # quality metric
]:
    if disable_rot:
        '''
        m_mouse @ m_transform = m_screen
        [mx 1] [a]   [sx ]
        [mx 1] [e] = [sx ]
        [...]        [...]
        
        [my 1] [d]   [sy ]
        [my 1] [f] = [sy ]
        [...1]       [...]
        '''
        (a, e), qual_x = fit(
            mouse_points=mouse_points[:, :1],
            screen_points=screen_points[:, 0], expected_rank=2,
        )
        (d, f), qual_y = fit(
            mouse_points=mouse_points[:, 1:],
            screen_points=screen_points[:, 1], expected_rank=2,
        )
        transform = np.array((
            (a, 0),
            (0, d),
            (e, f),
        ))
        quality = min(qual_x, qual_y)
    else:
        '''
        m_mouse @ m_transform = m_screen
        [mx my 1] [a b]   [sx sy]
        [mx my 1] [c d] = [sx sy]
        [...    ] [e f]   [...  ]
        '''
        transform, quality = fit(mouse_points, screen_points)

    transform = np.vstack((  # to homogeneous
        transform.T,
        [(0, 0, 1)],
    ))
    return transform, quality


def use_cal(dev_id: int, prop_name: str, new_cal: np.ndarray) -> None:
    cal_strings = (
        f'{x:.15g},'
        for row in new_cal for x in row
    )
    xinput('--set-prop', str(dev_id), prop_name, *cal_strings)
    print('The new calibration has been activated.')


def write_xorg_config(dev_id: int, dev_name: str, cal_prop: str, new_cal: np.ndarray) -> None:
    filename = '99-libinput-ts-calib.conf'
    now = datetime.datetime.now()
    path_prop, dev_path = read_prop(dev_id, ('Device Node',))
    cal_string = ' '.join(f'{x:.15g}' for x in new_cal.ravel())

    with open(filename, 'w') as f:
        f.write(
f'''# Generated by xcalibrate on {now:%x %X}

# https://www.x.org/releases/current/doc/man/man5/xorg.conf.5.xhtml#heading9
Section "InputClass"
    Identifier "{dev_name} touchscreen calibration"

    # For xinput device {dev_id}
    MatchDevicePath {dev_path}
    MatchProduct "{dev_name}"

    # For xinput property "{cal_prop}"
    Option "TransformationMatrix" "{cal_string}"
EndSection
''')

    print('To persist this calibration,')
    print(f'sudo mv {filename} /usr/share/X11/xorg.conf.d/')


def main() -> None:
    locale.setlocale(category=locale.LC_ALL, locale='')  # local date format

    devs = get_devs()
    if len(devs) < 1:
        print('Warning: no pointer devices found; showing all:')
        devs = get_devs(pointer_only=False)
    else:
        print('Pointer devices:')
    
    print_devs(devs)
    preferred = choose_preferred(devs)
    dev_id = choose_dev(devs, preferred)
    print()

    cal_prop, old_cal, old_cal_inv = read_cal(dev_id)

    new_cal = None
    if ask('Calibrate?'):
        n_points = choose_points()
        disable_rot = ask('Disable rotation and skew?')
        print()

        mouse_points, screen_points = show_tk(n_points, old_cal_inv)
        if len(mouse_points) >= 3:
            new_cal, quality = calibrate(mouse_points, screen_points, disable_rot)
            print('New calibration:')
            print(new_cal)
            print(f'Quality (should be at least 3): {quality:.1f}')
            print()

    if ask('Test?'):
        n_points = choose_points()
        show_tk(n_points, old_cal_inv, new_cal)

    if new_cal is not None and ask('Use calibration?'):
        use_cal(dev_id, cal_prop, new_cal)
        if ask('Write example xorg conf for persistence?'):
            write_xorg_config(dev_id, devs[dev_id], cal_prop, new_cal)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print()
