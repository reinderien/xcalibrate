#!/usr/bin/env python3
import datetime
import locale
import re
import subprocess
import typing

import numpy as np

if typing.TYPE_CHECKING:
    import tkinter


# Names of properties that could potentially have the calibration matrix, tested from top to bottom
PROP_NAMES = (
    'libinput Calibration Matrix',       # libinput driver only
    'Coordinate Transformation Matrix',  # fallback, probably evdev driver
)


def xinput(*args: str) -> str:
    """Run xinput with given args, check the exit code, and return its stdout"""
    return subprocess.check_output(
        args=('/usr/bin/xinput',) + args, text=True,
    )


def get_devs(pointer_only: bool = True) -> dict[int, str]:
    """
    List the xinput devices, parse out IDs and names, and (if pointer_only is true) only return
    devices reported as a pointer. This doesn't work for all touchscreens - some report as a
    keyboard.
    """
    pattern = r'''(?xim)
        ^.*?           # line start, any (lazy) prefix
        (?P<name>      # greedy name, beginning with a letter,
            [a-z].*\S  # ending with any non-space character
        )
        \s*id=         # ID marker
        (?P<id>        # numeric ID
            \d+
        )
        \s*
        \[?slave\s*%s  # must be a pointer device for pointer_only mode
    ''' % ('pointer' if pointer_only else '.+?')
    # stdout = xinput('--list', '--short')
    stdout = 'dummy device  id=0 [slave pointer]'
    matches = re.finditer(pattern, stdout)
    return {int(match['id']): match['name'] for match in matches}


def print_devs(devs: dict[int, str]) -> None:
    """Print device ID/name table"""
    print(f'{"ID":4s} {"Name":35s}')
    for i, name in sorted(devs.items()):
        print(f'{i:4d} {name:35s}')
    print()


def choose_preferred(devs: dict[int, str]) -> int:
    """Make a guess as to the most likely 'main touch' device"""
    preferred = next(
        (i for (i, n) in devs.items() if 'touch' in n.lower()),
        None,
    )
    if preferred is None:
        return next(iter(devs.keys()))
    return preferred


def choose_dev(devs: dict[int, str], preferred: int) -> int:
    """Choose the device to calibrate"""
    while True:
        devstr = input(f'Device to calibrate [{preferred}]: ')
        if devstr == '':
            return preferred
        try:
            dev = int(devstr)
        except ValueError:
            continue
        if dev in devs.keys():
            return dev


def read_prop(dev_id: int, names: tuple[str, ...]) -> tuple[str | None, str | None]:
    """Call xinput to read the first property whose name matches any in 'names'."""
    names = '|'.join(re.escape(name) for name in names)
    pattern = r'''(?xim)
        ^\s*      # line start, greedy spaces
        (?P<name>
            %s    # interpolated
        )
        \s*       # greedy spaces
        \(\d+\):  # numeric ID, not captured
        \s*       # greedy spaces
        (?P<value>
            .+?   # lazy value content
        )
        $         # line end
    ''' % names
    stdout = xinput('--list-props', str(dev_id))
    match = re.search(pattern, stdout)
    if match is None:
        return None, None
    return match['name'], match['value']


def read_cal(dev_id: int) -> tuple[
    str,         # xinput property name
    np.ndarray,  # calibration
    np.ndarray,  # inverse calibration
]:
    """Read the calibration matrix and parse it to a Numpy array."""
    # name, value = read_prop(dev_id, PROP_NAMES)
    name = 'libinput Calibration Matrix'
    value = '1.6,0,-0.2,0,1.8,-0.3,0,0,1'
    if name is None:
        print(f'$ xinput --list-props {dev_id}')
        print('does not contain any of these properties:')
        for name in PROP_NAMES:
            print('   ', name)
        print("So I don't know how to calibrate it.")
        exit(1)

    cal = np.fromstring(value, sep=',').reshape((3, 3))
    print(f'Old calibration ({name}):')
    print(cal)
    print()
    return name, cal, np.linalg.inv(cal)


def ask(q: str) -> bool:
    """Ask a yes-or-no question"""
    do = input(q + ' [y]: ')
    return (do or 'y')[:1].lower() == 'y'


def transform(x: float, y: float, cal: np.ndarray) -> np.ndarray:
    """Transform x, y scalars by the given calibration matrix. Output is non-homogeneous."""
    return cal[:2, :] @ (x, y, 1)


class GUI:
    RAW_COLOUR = '#000'
    TRACE_COLOUR = '#CCC'
    OLD_CAL_COLOUR = '#090'
    NEW_CAL_COLOUR = '#F4F'
    CURRENT_COLOUR = '#F00'
    NEXT_COLOUR = '#00F'
    
    __slots__ = (
        'old_cal_inv', 'new_cal', 'testing', 'n_lines', 'index', 'prev_old', 'prev_touch',
        'current_touch_points', 'all_touch_points',
        'root', 'canvas', 'w', 'h', 'vertices', 'ab', 'line_ids',
    )

    def __init__(
        self, old_cal_inv: np.ndarray, new_cal: np.ndarray | None = None, n_lines: int = 5,
    ) -> None:
        import tkinter

        self.old_cal_inv = old_cal_inv
        self.new_cal = new_cal
        self.testing = new_cal is not None
        self.n_lines = n_lines
        self.index = 0
        self.prev_old: tuple[float | None, float | None] = None, None
        self.prev_touch: tuple[float | None, float | None] = None, None
        self.current_touch_points = []
        self.all_touch_points = []

        self.root = root = tkinter.Tk()
        root.bind('<Escape>', self.cancel)

        self.canvas = canvas = tkinter.Canvas(root, name='cal_canvas')
        canvas.bind('<Configure>', self.resize)
        canvas.bind('<Button-1>', self.touchdown)
        canvas.bind('<B1-Motion>', self.touchmove)
        canvas.bind('<ButtonRelease-1>', self.touchup)
        canvas.bind('<Escape>', self.cancel)

        root.attributes('-fullscreen', True)
        # as the above line doesn't work on all screens we also force the geometry to be the full size
        self.w = w = root.winfo_screenwidth()
        self.h = h = root.winfo_screenheight()
        root.geometry(f'{w}x{h}')

        canvas.pack(expand=True, fill='both')

        self.vertices, self.ab = self.make_vertices()
        scaled = self.vertices*(w, h)
        self.line_ids = tuple([
            self.canvas.create_line(
                *scaled[i], *scaled[(i + 1)%n_lines],
                fill=self.TRACE_COLOUR, width=2,
            )
            for i in range(n_lines)
        ])

    def main_loop(self) -> None:
        self.root.mainloop()

    def make_vertices(self, aoffset: float = 0.1) -> tuple[np.ndarray, np.ndarray]:
        """Make vertices and edge linear parameters for the trace polygon"""
        n = self.n_lines
        angles = np.linspace(
            start=2*np.pi/n*aoffset, stop=2*np.pi*(1 - (1 - aoffset)/n), num=n,
        )
        radius = 0.4  # normalised
        vertices = 0.5 + radius*np.stack((
            np.cos(angles), np.sin(angles),
        ))
        vertices.flags.writeable = False

        x0, y0 = vertices
        x1, y1 = np.roll(vertices, shift=1, axis=1)
        # To form ax + by = 1
        ab = np.stack((y1-y0, x0-x1))/(x0*y1 - x1*y0)
        ab.flags.writeable = False

        return vertices.T, ab.T

    def resize(self, event: 'tkinter.Event') -> None:
        """Called on resize of the window (including when the window first appears)"""
        self.w = event.width
        self.h = event.height
        scaled = (self.w, self.h)*self.vertices
        for i, (line, (x0, y0)) in enumerate(zip(self.line_ids, scaled)):
            x1, y1 = scaled[(i + 1)%self.n_lines]
            self.canvas.coords(line, x0, y0, x1, y1)

        self.legend(0, 'Esc to cancel')
        self.legend(1, 'Trace red line now', self.CURRENT_COLOUR)
        self.legend(2, 'Trace blue line next', self.NEXT_COLOUR)
        self.legend(3, 'Raw touch in black', self.RAW_COLOUR)
        self.legend(4, 'Old cal output in green', self.OLD_CAL_COLOUR)
        self.legend(5, 'New cal output in purple', self.NEW_CAL_COLOUR)

        self.next_line()

    def legend(self, y: int, text: str, colour: str = '#000') -> None:
        """Draw one text caption line"""
        self.canvas.create_text(0.5*self.w, 0.5*self.h + 12*y, text=text, fill=colour)

    def finish_line(self) -> None:
        """Complete the logic for this polygon edge"""
        self.canvas.itemconfigure(self.line_ids[self.index], fill=self.TRACE_COLOUR)
        self.index = (self.index + 2)%self.n_lines

    def next_line(self) -> None:
        """Activate the next polygon edge"""
        self.current_touch_points = []
        self.all_touch_points.append(self.current_touch_points)
        self.canvas.itemconfigure(self.line_ids[self.index], fill=self.CURRENT_COLOUR)
        self.canvas.itemconfigure(self.line_ids[(self.index + 2)%self.n_lines], fill=self.NEXT_COLOUR)

    def cancel(self, event: 'tkinter.Event') -> None:
        print('Calibration cancelled')
        # clear the calibrated points
        self.root.destroy()

    def indicator_segment(
        self, x0: float, y0: float, x1: float, y1: float,
        colour: str, trans: np.ndarray | None = None,
    ) -> np.ndarray:
        """
        Draw one (potentially transformed) piece of a user trace; there will be many of these per
        polygon edge
        """
        if trans is None:
            xy1 = x1, y1
        else:
            xy = trans[:2, :] @ ((x0, x1),
                                 (y0, y1),
                                 ( 1,  1))
            ((x0, x1),
             (y0, y1)) = xy
            xy1 = xy[:, 1]
        w, h = self.w, self.h
        self.canvas.create_line(x0*w, y0*h, x1*w, y1*h, width=1, fill=colour)
        return xy1

    def touchdown(self, event: 'tkinter.Event') -> None:
        """
        Called when the user starts a touch-drag. If this lands far enough away from the other
        points in this segment, move to the next segment.
        """
        ox, oy = event.x/self.w, event.y/self.h
        ux, uy = self.old_cal_inv[:2, :] @ (ox, oy, 1)
        if len(self.current_touch_points) >= 2:
            x0, y0 = np.min(self.current_touch_points, axis=0)
            x1, y1 = np.max(self.current_touch_points, axis=0)
            dx = x1 - x0
            dy = y1 - y0
            if not (-0.5*dx < ux - x0 < 1.5*dx and   # -0.5 < (x - x0)/(x1 - x0) < 1.5
                    -0.5*dy < uy - y0 < 1.5*dy):
                self.finish_line()
                self.next_line()

        self.prev_old = ox, oy
        self.prev_touch = ux, uy
        self.current_touch_points.append(self.prev_touch)

    def touchup(self, event: 'tkinter.Event') -> None:
        """
        Called when the user releases touch. This doesn't necessarily complete the segment. This is
        used as a somewhat arbitrary time to update the new calibration matrix. If this happens
        during the last segment, the calibration will complete.
        """
        if len(self.all_touch_points) >= 3:
            uxy = np.concat(self.all_touch_points, axis=0)
            ux, uy = uxy.T
            idx = np.arange(0, 2*len(self.all_touch_points), 2) % self.n_lines
            sab = np.repeat(self.ab[idx], [len(p) for p in self.all_touch_points], axis=0)
            sa, sb = sab.T
            lhs = np.stack(
                (
                    sa*ux, sb*ux,
                    sa*uy, sb*uy,
                    sa, sb,
                ), axis=1,
            )
            rhs = np.ones_like(ux)
            trans, residuals, rank, singular = np.linalg.lstsq(a=lhs, b=rhs)
            trans = trans.reshape((3, 2))
            self.new_cal = np.hstack((trans, [[0],[0],[1]]))

        if self.index == self.n_lines - 2:
            self.legend(6, 'Done, closing.')
            self.root.after(1000, self.root.destroy)

    def touchmove(self, event: 'tkinter.Event') -> None:
        w, h = self.w, self.h
        ox0, oy0 = self.prev_old
        ux0, uy0 = self.prev_touch
        ox1, oy1 = event.x/w, event.y/h
        ux1, uy1 = self.indicator_segment(ox0, oy0, ox1, oy1, self.RAW_COLOUR, self.old_cal_inv)
        self.indicator_segment(ox0, oy0, ox1, oy1, self.OLD_CAL_COLOUR)
        if self.new_cal is not None:
            self.indicator_segment(ux0, uy0, ux1, uy1, self.NEW_CAL_COLOUR, self.new_cal)
        self.prev_old = ox1, oy1
        self.prev_touch = ux1, uy1
        self.current_touch_points.append(self.prev_touch)


def fit(
    touch_points: np.ndarray, screen_points: np.ndarray, expected_rank: int = 3,
) -> tuple[
    np.ndarray,  # transform matrix
    float,       # quality metric
]:
    homogenous_touch = np.hstack((
        touch_points,
        np.ones_like(touch_points, shape=(len(touch_points), 1)),
    ))
    transform, residuals, rank, singular = np.linalg.lstsq(homogenous_touch, screen_points, rcond=None)
    if rank != expected_rank:
        print(f'Warning: deficient transformation of rank {rank}. Please try calibrating again.')
    quality = -np.log10(residuals.mean())
    return transform, quality


def calibrate(
    touch_points: np.ndarray, screen_points: np.ndarray, disable_rot: bool,
) -> tuple[
    np.ndarray,  # new cal matrix
    float,       # quality metric
]:
    if disable_rot:
        '''
        m_touch @ m_transform = m_screen
        [mx 1] [a]   [sx ]
        [mx 1] [e] = [sx ]
        [...]        [...]
        
        [my 1] [d]   [sy ]
        [my 1] [f] = [sy ]
        [...1]       [...]
        '''
        (a, e), qual_x = fit(
            touch_points=touch_points[:, :1],
            screen_points=screen_points[:, 0], expected_rank=2,
        )
        (d, f), qual_y = fit(
            touch_points=touch_points[:, 1:],
            screen_points=screen_points[:, 1], expected_rank=2,
        )
        transform = np.array((
            (a, 0),
            (0, d),
            (e, f),
        ))
        quality = min(qual_x, qual_y)
    else:
        '''
        m_touch @ m_transform = m_screen
        [mx my 1] [a b]   [sx sy]
        [mx my 1] [c d] = [sx sy]
        [...    ] [e f]   [...  ]
        '''
        transform, quality = fit(touch_points, screen_points)

    transform = np.vstack((  # to homogeneous
        transform.T,
        [(0, 0, 1)],
    ))
    return transform, quality


def use_cal(dev_id: int, prop_name: str, new_cal: np.ndarray) -> None:
    cal_strings = (
        f'{x:.15g},'
        for row in new_cal for x in row
    )
    xinput('--set-prop', str(dev_id), prop_name, *cal_strings)
    print('The new calibration has been activated.')


def write_xorg_config(dev_id: int, dev_name: str, cal_prop: str, new_cal: np.ndarray) -> None:
    filename = '99-libinput-ts-calib.conf'
    now = datetime.datetime.now()
    path_prop, dev_path = read_prop(dev_id, ('Device Node',))
    cal_string = ' '.join(f'{x:.15g}' for x in new_cal.ravel())

    with open(filename, 'w') as f:
        f.write(
f'''# Generated by xcalibrate on {now:%x %X}

# https://www.x.org/releases/current/doc/man/man5/xorg.conf.5.xhtml#heading9
Section "InputClass"
    Identifier "{dev_name} touchscreen calibration"

    # For xinput device {dev_id}
    MatchDevicePath {dev_path}
    MatchProduct "{dev_name}"

    # For xinput property "{cal_prop}"
    Option "TransformationMatrix" "{cal_string}"
EndSection
''')

    print('To persist this calibration,')
    print(f'sudo mv {filename} /usr/share/X11/xorg.conf.d/')


def main() -> None:
    locale.setlocale(category=locale.LC_ALL, locale='')  # local date format

    devs = get_devs()
    if len(devs) < 1:
        print('Warning: no pointer devices found; showing all:')
        devs = get_devs(pointer_only=False)
    else:
        print('Pointer devices:')
    
    print_devs(devs)
    preferred = choose_preferred(devs)
    dev_id = 0  # choose_dev(devs, preferred)
    print()

    cal_prop, old_cal, old_cal_inv = read_cal(dev_id)

    new_cal = None
    disable_rot = False  # ask('Disable rotation and skew?')
    print()

    ui = GUI(old_cal_inv)
    ui.main_loop()
    raise NotImplementedError()
    if len(touch_points) >= 3:
        new_cal, quality = calibrate(touch_points, screen_points, disable_rot)
        print('New calibration:')
        print(new_cal)
        print(f'Quality (should be at least 3): {quality:.1f}')
        print()

    if ask('Test?'):
        show_tk(n_lines, old_cal_inv, new_cal)

    if new_cal is not None and ask('Use calibration?'):
        use_cal(dev_id, cal_prop, new_cal)
        if ask('Write example xorg conf for persistence?'):
            write_xorg_config(dev_id, devs[dev_id], cal_prop, new_cal)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print()
