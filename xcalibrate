#!/usr/bin/env python3

import re
import numpy as np
import subprocess


PROP_NAMES = (
    'libinput Calibration Matrix',
    'Coordinate Transformation Matrix',
)


def xinput(*args: str) -> str:
    return subprocess.check_output(
        args=('/usr/bin/xinput', *args),
        text=True,
    )


def get_devs() -> dict[int, str]:
    stdout = xinput('--list', '--short')
    matches = re.finditer(r'''(?xim)
        ^.*?           # line start, any (lazy) prefix
        (?P<name>      # greedy name, beginning with a letter,
            [a-z].*\S  # ending with any non-space character
        )
        \s*id=         # ID marker
        (?P<id>        # numeric ID
            \d+
        )
        \s*
        \[?slave\s*pointer  # must be a pointer device
    ''', stdout)
    devs = {int(match['id']): match['name'] for match in matches}
    if len(devs) < 1:
        print('No suitable input devices found')
        exit(1)
    return devs


def print_devs(devs: dict[int, str]) -> None:
    print('Pointer devices:')
    print(f'{"ID":4s} {"Name":35s}')
    for i, name in sorted(devs.items()):
        print(f'{i:4d} {name:35s}')
    print()


def choose_preferred(devs: dict[int, str]) -> int:
    preferred = next(
        (i for (i, n) in devs.items() if 'touch' in n.lower()),
        None
    )
    if preferred is None:
        return next(iter(devs.keys()))
    return preferred


def choose_dev(devs: dict[int, str], preferred: int) -> int:
    while True:
        devstr = input(f'Device to calibrate [{preferred}]: ')
        if devstr == '':
            return preferred
        try:
            dev = int(devstr)
        except ValueError:
            continue
        if dev in devs.keys():
            return dev


def read_cal(dev: int) -> tuple[
    str,         # xinput property name
    np.ndarray,  # calibration
    np.ndarray,  # inverse calibration
]:
    names = '|'.join(re.escape(name) for name in PROP_NAMES)
    pattern = r'''(?xim)
        ^\s*      # line start, greedy spaces
        (?P<name>
            %s    # interpolated
        )
        \s*       # greedy spaces
        \(\d+\):  # numeric ID, not captured
        \s*       # greedy spaces
        (?P<value>
            .+?   # lazy value content
        )
        $         # line end
    ''' % names
    stdout = xinput('--list-props', str(dev))
    match = re.search(pattern, stdout)
    if match is None:
        print('Calibration matrix property not set; is this an xinput device?')
        exit(1)

    name = match['name']
    cal = np.fromstring(match['value'], sep=',').reshape((3, 3))

    print(f'Old calibration ({name}):')
    print(cal)
    print()
    return name, cal, np.linalg.inv(cal)


def ask(q: str) -> bool:
    do = input(q + ' [y]: ')
    return (do or 'y')[:1].lower() == 'y'


def choose_points(p_min: int = 3, default: int = 4) -> int:
    while True:
        p_str = input(f'Point count (min {p_min}) [{default}]: ')
        if p_str == '':
            return default
        try:
            p = int(p_str)
        except ValueError:
            continue

        if p >= p_min:
            return p


def transform(x: float, y: float, cal: np.ndarray) -> np.ndarray:
    out = cal @ (x, y, 1)
    return out[:2]


def show_tk(n_points: int, old_cal_inv: np.ndarray, new_cal: np.ndarray | None = None) -> list:
    from tkinter import Tk, Canvas

    root = Tk()
    X, Y = None, None
    root.attributes('-fullscreen', True)
    # as the above line doesn't work on all screens
    # we force the geometry to be the fullsize with next two lines
    w,h = root.winfo_screenwidth(), root.winfo_screenheight()
    root.geometry(f'{w}x{h}')
    canvas = Canvas(root)

    def resize(event) -> None:
        nonlocal X, Y
        X, Y = event.width, event.height
        draw_legends()
        next_point()
    canvas.bind('<Configure>', resize)
    canvas.pack(expand=True, fill='both')

    legend_y = None

    def legend(text: str, colour: str = '#000') -> None:
        nonlocal legend_y
        canvas.create_text(X/2, legend_y, text=text, fill=colour)
        legend_y += 12

    def draw_legends() -> None:
        nonlocal legend_y
        legend_y = Y * 0.3
        legend('Esc to cancel.')
        legend('Raw point in black')
        legend('Old cal point in blue', '#00F')
        legend('Target point in red', '#F00')
        if new_cal is not None:
            legend('New cal point in green', '#0F0')

    point, points = {}, []
    index = -1
    n_cols = int(np.ceil(np.sqrt(n_points)))
    n_rows = int(np.ceil(n_points / n_cols))
    sensitive = False

    def next_point() -> None:
        nonlocal point, index, sensitive
        index += 1
        if index >= n_points:
            sensitive = False
            root.after(1000, root.destroy)
        else:
            sensitive = True
            vert, horz = divmod(index, n_cols)
            x = 0.1 + 0.8*horz/(n_cols - 1)
            y = 0.1 + 0.8*vert/(n_rows - 1)
            point = {'sx': x, 'sy': y}

            draw_target(point['sx'], point['sy'])

    def cross(px: float, py: float, colour: str) -> None:
        x, y = px*X, py*Y
        canvas.create_line(x-10, y, x+10, y, fill=colour)
        canvas.create_line(x, y-10, x, y+10, fill=colour)

    def draw_target(px: float, py: float) -> None:
        x, y = px*X, py*Y
        canvas.create_oval(x-10, y-10, x+10, y+10, outline='#F00', width=3)
        cross(px, py, '#F00')

    def cancel_cal(_) -> None:
        print('Calibration cancelled')
        points.clear()
        root.destroy()
    root.bind('<Escape>', cancel_cal)
    canvas.bind('<Escape>', cancel_cal)

    def indicator(sx: float, sy: float, px: float, py: float, colour: str) -> None:
        canvas.create_line(X*sx, Y*sy, X*px, Y*py, fill=colour)
        cross(px, py, colour)

    def click(event) -> None:
        nonlocal sensitive
        if not sensitive:
            return
        sensitive = False
    
        sx, sy = point['sx'], point['sy']

        ox, oy = event.x/X, event.y/Y  # old-calibrated
        indicator(sx, sy, ox, oy, '#00F')

        ux, uy = transform(ox, oy, old_cal_inv)  # uncalibrated
        indicator(sx, sy, ux, uy, '#000')

        if new_cal is not None:
            nx, ny = transform(ux, uy, new_cal)  # new-calibrated (test only)
            indicator(sx, sy, nx, ny, '#0F0')

        point.update({'mx': ux, 'my': uy})
        points.append(point)

        canvas.after(500, next_point)
    canvas.bind('<Button-1>', click)

    root.mainloop()

    return points


def fit(screen_pts, mouse_pts) -> tuple[
    np.ndarray,  # transform matrix
    float,       # quality metric
]:
    m_screen = np.array([(*p, 1) for p in screen_pts])
    m_mouse = np.array([(*p, 1) for p in mouse_pts])
    m_transform, residuals, rank, singular = np.linalg.lstsq(m_mouse, m_screen, rcond=None)
    quality = -np.log10(residuals.sum())
    return m_transform, quality


def calibrate(points, disable_rot: bool) -> tuple[
    np.ndarray,  # new cal matrix
    float,       # quality metric
]:
    if disable_rot:
        '''
        [mx 1] [a 0]   [sx 1]
        [mx 1] [e 1] = [sx 1]
        [... ]         [... ]
        
        [my 1] [d 0]   [sy 1]
        [my 1] [f 1] = [sy 1]
        [... ]         [... ]
        '''
        tx, qual_x = fit(screen_pts=((p['sx'],) for p in points),
                         mouse_pts=((p['mx'],) for p in points))
        ty, qual_y = fit(screen_pts=((p['sy'],) for p in points),
                         mouse_pts=((p['my'],) for p in points))
        m_transform = np.array([
            [tx[0, 0], 0,        0],
            [0,        ty[0, 0], 0],
            [tx[1, 0], ty[1, 0], 1]])
        quality = min(qual_x, qual_y)
    else:
        '''
        m_mouse * m_transform = m_screen
        [mx my 1] [a b 0]   [sx sy 1]
        [mx my 1] [c d 0] = [sx sy 1]
        [...    ] [e f 1]   [...    ]
        '''
        m_transform, quality = fit(screen_pts=[(p['sx'], p['sy']) for p in points],
                                   mouse_pts=[(p['mx'], p['my']) for p in points])
        m_transform[:, 2] = 0, 0, 1

    return m_transform.T, quality


def use_cal(dev: int, prop_name: str, new_cal: np.ndarray) -> None:
    cal_strings = (
        f'{x:.15g},'
        for row in new_cal for x in row
    )
    xinput('--set-prop', str(dev), prop_name, *cal_strings)
    print('The new calibration has been activated.')


def print_xorg_config(dev_name: str, prop_name: str, new_cal: np.ndarray) -> None:
    cal_string = ' '.join(
        f'{x:.15g}'
        for row in new_cal for x in row
    )
    print(
f'''To persist, create e.g.
/usr/share/X11/xorg.conf.d/99-libinput-ts-calib.conf
and add the following:

Section "InputClass"
    Identifier      "calibration"
    MatchProduct    "{dev_name}"
    Option          "{prop_name}"  "{cal_string}"
EndSection
''')


def main() -> None:
    devs = get_devs()
    print_devs(devs)
    preferred = choose_preferred(devs)
    dev = choose_dev(devs, preferred)
    print()

    prop_name, old_cal, old_cal_inv = read_cal(dev)

    new_cal = None
    if ask('Calibrate?'):
        n_points = choose_points()
        disable_rot = ask('Disable rotation?')
        print()

        points = show_tk(n_points, old_cal_inv)
        if points:
            new_cal, quality = calibrate(points, disable_rot)

            print('New calibration:')
            print(new_cal)
            print(f'Quality (should be at least 3): {quality:.1f}')
            print()

    if ask('Test?'):
        n_points = choose_points()
        show_tk(n_points, old_cal_inv, new_cal)

    if new_cal is not None and ask('Use calibration?'):
        use_cal(dev, prop_name, new_cal)
        print_xorg_config(devs[dev], prop_name, new_cal)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print()
